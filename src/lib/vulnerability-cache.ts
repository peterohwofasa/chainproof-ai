import { redisClient } from './redis'
import { VulnerabilityPattern } from './vulnerability-database'
import crypto from 'crypto'

export interface CachedAnalysisResult {
  vulnerabilities: any[]
  overallScore: number
  riskLevel: string
  analysisMethod: string
  timestamp: number
  cacheVersion: string
}

export interface CachedPatternResult {
  pattern: VulnerabilityPattern
  matches: Array<{
    line: number
    snippet: string
    confidence: number
  }>
  timestamp: number
}

class VulnerabilityCache {
  private readonly CACHE_VERSION = '1.0.0'
  private readonly ANALYSIS_TTL = 24 * 60 * 60 // 24 hours in seconds
  private readonly PATTERN_TTL = 7 * 24 * 60 * 60 // 7 days in seconds
  private readonly HASH_TTL = 30 * 24 * 60 * 60 // 30 days in seconds

  /**
   * Generate a hash for contract code to use as cache key
   */
  private generateCodeHash(contractCode: string): string {
    return crypto.createHash('sha256').update(contractCode.trim()).digest('hex')
  }

  /**
   * Generate a hash for pattern matching to use as cache key
   */
  private generatePatternHash(contractCode: string, patternId: string): string {
    const combined = `${contractCode.trim()}:${patternId}:${this.CACHE_VERSION}`
    return crypto.createHash('sha256').update(combined).digest('hex')
  }

  /**
   * Cache complete analysis results
   */
  async cacheAnalysisResult(
    contractCode: string,
    result: Omit<CachedAnalysisResult, 'timestamp' | 'cacheVersion'>
  ): Promise<void> {
    try {
      const codeHash = this.generateCodeHash(contractCode)
      const cacheKey = `analysis:${codeHash}`
      
      const cachedResult: CachedAnalysisResult = {
        ...result,
        timestamp: Date.now(),
        cacheVersion: this.CACHE_VERSION
      }

      await redisClient.setex(cacheKey, this.ANALYSIS_TTL, JSON.stringify(cachedResult))
      
      // Also cache the hash mapping for debugging
      const hashKey = `hash:${codeHash}`
      await redisClient.setex(hashKey, this.HASH_TTL, contractCode.substring(0, 200))
      
      console.log(`Cached analysis result for contract hash: ${codeHash}`)
    } catch (error) {
      console.warn('Failed to cache analysis result:', error)
    }
  }

  /**
   * Retrieve cached analysis results
   */
  async getCachedAnalysisResult(contractCode: string): Promise<CachedAnalysisResult | null> {
    try {
      const codeHash = this.generateCodeHash(contractCode)
      const cacheKey = `analysis:${codeHash}`
      
      const cached = await redisClient.get(cacheKey)
      if (!cached) {
        return null
      }

      const result: CachedAnalysisResult = JSON.parse(cached)
      
      // Check cache version compatibility
      if (result.cacheVersion !== this.CACHE_VERSION) {
        console.log(`Cache version mismatch for ${codeHash}, invalidating`)
        await redisClient.del(cacheKey)
        return null
      }

      // Check if cache is still fresh (additional TTL check)
      const age = Date.now() - result.timestamp
      if (age > this.ANALYSIS_TTL * 1000) {
        await redisClient.del(cacheKey)
        return null
      }

      console.log(`Retrieved cached analysis for contract hash: ${codeHash}`)
      return result
    } catch (error) {
      console.warn('Failed to retrieve cached analysis:', error)
      return null
    }
  }

  /**
   * Cache individual pattern matching results
   */
  async cachePatternResult(
    contractCode: string,
    patternId: string,
    result: Omit<CachedPatternResult, 'timestamp'>
  ): Promise<void> {
    try {
      const patternHash = this.generatePatternHash(contractCode, patternId)
      const cacheKey = `pattern:${patternHash}`
      
      const cachedResult: CachedPatternResult = {
        ...result,
        timestamp: Date.now()
      }

      await redisClient.setex(cacheKey, this.PATTERN_TTL, JSON.stringify(cachedResult))
      console.log(`Cached pattern result for ${patternId}: ${patternHash}`)
    } catch (error) {
      console.warn(`Failed to cache pattern result for ${patternId}:`, error)
    }
  }

  /**
   * Retrieve cached pattern matching results
   */
  async getCachedPatternResult(
    contractCode: string,
    patternId: string
  ): Promise<CachedPatternResult | null> {
    try {
      const patternHash = this.generatePatternHash(contractCode, patternId)
      const cacheKey = `pattern:${patternHash}`
      
      const cached = await redisClient.get(cacheKey)
      if (!cached) {
        return null
      }

      const result: CachedPatternResult = JSON.parse(cached)
      
      // Check if cache is still fresh
      const age = Date.now() - result.timestamp
      if (age > this.PATTERN_TTL * 1000) {
        await redisClient.del(cacheKey)
        return null
      }

      console.log(`Retrieved cached pattern result for ${patternId}: ${patternHash}`)
      return result
    } catch (error) {
      console.warn(`Failed to retrieve cached pattern result for ${patternId}:`, error)
      return null
    }
  }

  /**
   * Cache multiple pattern results in batch
   */
  async cachePatternResults(
    contractCode: string,
    results: Array<{ patternId: string; result: Omit<CachedPatternResult, 'timestamp'> }>
  ): Promise<void> {
    const pipeline = redisClient.pipeline()
    
    for (const { patternId, result } of results) {
      try {
        const patternHash = this.generatePatternHash(contractCode, patternId)
        const cacheKey = `pattern:${patternHash}`
        
        const cachedResult: CachedPatternResult = {
          ...result,
          timestamp: Date.now()
        }

        pipeline.setex(cacheKey, this.PATTERN_TTL, JSON.stringify(cachedResult))
      } catch (error) {
        console.warn(`Failed to prepare cache for pattern ${patternId}:`, error)
      }
    }

    try {
      await pipeline.exec()
      console.log(`Batch cached ${results.length} pattern results`)
    } catch (error) {
      console.warn('Failed to execute batch pattern cache:', error)
    }
  }

  /**
   * Retrieve multiple cached pattern results in batch
   */
  async getCachedPatternResults(
    contractCode: string,
    patternIds: string[]
  ): Promise<Map<string, CachedPatternResult>> {
    const results = new Map<string, CachedPatternResult>()
    const pipeline = redisClient.pipeline()
    
    // Prepare all cache keys
    const keyMap = new Map<string, string>()
    for (const patternId of patternIds) {
      const patternHash = this.generatePatternHash(contractCode, patternId)
      const cacheKey = `pattern:${patternHash}`
      keyMap.set(cacheKey, patternId)
      pipeline.get(cacheKey)
    }

    try {
      const pipelineResults = await pipeline.exec()
      
      if (pipelineResults) {
        for (let i = 0; i < pipelineResults.length; i++) {
          const [error, cached] = pipelineResults[i]
          if (!error && cached) {
            try {
              const result: CachedPatternResult = JSON.parse(cached as string)
              const cacheKey = Array.from(keyMap.keys())[i]
              const patternId = keyMap.get(cacheKey)!
              
              // Check if cache is still fresh
              const age = Date.now() - result.timestamp
              if (age <= this.PATTERN_TTL * 1000) {
                results.set(patternId, result)
              }
            } catch (parseError) {
              console.warn('Failed to parse cached pattern result:', parseError)
            }
          }
        }
      }

      console.log(`Retrieved ${results.size}/${patternIds.length} cached pattern results`)
    } catch (error) {
      console.warn('Failed to retrieve batch pattern cache:', error)
    }

    return results
  }

  /**
   * Invalidate cache for a specific contract
   */
  async invalidateContractCache(contractCode: string): Promise<void> {
    try {
      const codeHash = this.generateCodeHash(contractCode)
      const analysisKey = `analysis:${codeHash}`
      const hashKey = `hash:${codeHash}`
      
      await redisClient.del(analysisKey, hashKey)
      console.log(`Invalidated cache for contract hash: ${codeHash}`)
    } catch (error) {
      console.warn('Failed to invalidate contract cache:', error)
    }
  }

  /**
   * Get cache statistics
   */
  async getCacheStats(): Promise<{
    analysisCount: number
    patternCount: number
    totalKeys: number
  }> {
    try {
      const [analysisKeys, patternKeys, allKeys] = await Promise.all([
        redisClient.keys('analysis:*'),
        redisClient.keys('pattern:*'),
        redisClient.keys('*')
      ])

      return {
        analysisCount: analysisKeys.length,
        patternCount: patternKeys.length,
        totalKeys: allKeys.length
      }
    } catch (error) {
      console.warn('Failed to get cache stats:', error)
      return { analysisCount: 0, patternCount: 0, totalKeys: 0 }
    }
  }

  /**
   * Clear all vulnerability cache
   */
  async clearCache(): Promise<void> {
    try {
      const keys = await redisClient.keys('analysis:*')
      const patternKeys = await redisClient.keys('pattern:*')
      const hashKeys = await redisClient.keys('hash:*')
      
      const allKeys = [...keys, ...patternKeys, ...hashKeys]
      if (allKeys.length > 0) {
        await redisClient.del(...allKeys)
        console.log(`Cleared ${allKeys.length} cache entries`)
      }
    } catch (error) {
      console.warn('Failed to clear cache:', error)
    }
  }
}

export const vulnerabilityCache = new VulnerabilityCache()