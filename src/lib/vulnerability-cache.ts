// Redis has been removed - using in-memory cache only
import { VulnerabilityPattern } from './vulnerability-database'
import { createHash } from 'crypto'

// In-memory cache implementation for when Redis is disabled
class InMemoryVulnerabilityCache {
  private analysisCache = new Map<string, { data: CachedAnalysisResult; expiry: number }>()
  private patternCache = new Map<string, { data: CachedPatternResult; expiry: number }>()
  private hashCache = new Map<string, { data: string; expiry: number }>()

  set(key: string, value: any, ttlSeconds: number, type: 'analysis' | 'pattern' | 'hash'): void {
    const expiry = Date.now() + (ttlSeconds * 1000)
    const cache = type === 'analysis' ? this.analysisCache : 
                  type === 'pattern' ? this.patternCache : this.hashCache
    cache.set(key, { data: value, expiry })
  }

  get(key: string, type: 'analysis' | 'pattern' | 'hash'): any | null {
    const cache = type === 'analysis' ? this.analysisCache : 
                  type === 'pattern' ? this.patternCache : this.hashCache
    const entry = cache.get(key)
    if (!entry) return null
    
    if (Date.now() > entry.expiry) {
      cache.delete(key)
      return null
    }
    
    return entry.data
  }

  delete(key: string, type: 'analysis' | 'pattern' | 'hash'): void {
    const cache = type === 'analysis' ? this.analysisCache : 
                  type === 'pattern' ? this.patternCache : this.hashCache
    cache.delete(key)
  }

  clear(): void {
    this.analysisCache.clear()
    this.patternCache.clear()
    this.hashCache.clear()
  }

  getStats(): { analysisCount: number; patternCount: number; totalKeys: number } {
    // Clean expired entries first
    const now = Date.now()
    Array.from(this.analysisCache.entries()).forEach(([key, entry]) => {
      if (entry.expiry < now) {
        this.analysisCache.delete(key)
      }
    })
    Array.from(this.patternCache.entries()).forEach(([key, entry]) => {
      if (entry.expiry < now) {
        this.patternCache.delete(key)
      }
    })
    Array.from(this.hashCache.entries()).forEach(([key, entry]) => {
      if (entry.expiry < now) {
        this.hashCache.delete(key)
      }
    })

    return {
      analysisCount: this.analysisCache.size,
      patternCount: this.patternCache.size,
      totalKeys: this.analysisCache.size + this.patternCache.size + this.hashCache.size
    }
  }
}

export interface CachedAnalysisResult {
  vulnerabilities: any[]
  overallScore: number
  riskLevel: string
  analysisMethod: string
  timestamp: number
  cacheVersion: string
}

export interface CachedPatternResult {
  pattern: VulnerabilityPattern
  matches: Array<{
    line: number
    snippet: string
    confidence: number
  }>
  timestamp: number
}

class VulnerabilityCache {
  private readonly CACHE_VERSION = '1.0.0'
  private readonly ANALYSIS_TTL = 24 * 60 * 60 // 24 hours in seconds
  private readonly PATTERN_TTL = 7 * 24 * 60 * 60 // 7 days in seconds
  private readonly HASH_TTL = 30 * 24 * 60 * 60 // 30 days in seconds
  private readonly inMemoryCache = new InMemoryVulnerabilityCache()

  /**
   * Generate a hash for contract code to use as cache key
   */
  private generateCodeHash(contractCode: string): string {
    return createHash('sha256').update(contractCode.trim()).digest('hex')
  }

  /**
   * Generate a hash for pattern matching to use as cache key
   */
  private generatePatternHash(contractCode: string, patternId: string): string {
    const combined = `${contractCode.trim()}:${patternId}:${this.CACHE_VERSION}`
    return createHash('sha256').update(combined).digest('hex')
  }

  /**
   * Cache complete analysis results
   */
  async cacheAnalysisResult(
    contractCode: string,
    result: Omit<CachedAnalysisResult, 'timestamp' | 'cacheVersion'>
  ): Promise<void> {
    try {
      const codeHash = this.generateCodeHash(contractCode)
      const cacheKey = `analysis:${codeHash}`
      
      const cachedResult: CachedAnalysisResult = {
        ...result,
        timestamp: Date.now(),
        cacheVersion: this.CACHE_VERSION
      }

      // Use in-memory cache (Redis has been removed)
      this.inMemoryCache.set(cacheKey, cachedResult, this.ANALYSIS_TTL, 'analysis')
      const hashKey = `hash:${codeHash}`
      this.inMemoryCache.set(hashKey, contractCode.substring(0, 200), this.HASH_TTL, 'hash')
      
      console.log(`Cached analysis result for contract hash: ${codeHash}`)
    } catch (error) {
      console.warn('Failed to cache analysis result:', error)
    }
  }

  /**
   * Retrieve cached analysis results
   */
  async getCachedAnalysisResult(contractCode: string): Promise<CachedAnalysisResult | null> {
    try {
      const codeHash = this.generateCodeHash(contractCode)
      const cacheKey = `analysis:${codeHash}`
      
      // Use in-memory cache (Redis has been removed)
      const result: CachedAnalysisResult | null = this.inMemoryCache.get(cacheKey, 'analysis')
      
      if (!result) {
        return null
      }

      // Check if cache is still valid (not expired and version matches)
      const now = Date.now()
      const cacheAge = now - result.timestamp
      const isExpired = cacheAge > (this.ANALYSIS_TTL * 1000)
      const isVersionMismatch = result.cacheVersion !== this.CACHE_VERSION

      if (isExpired || isVersionMismatch) {
        // Remove expired or outdated cache
        this.inMemoryCache.delete(cacheKey, 'analysis')
        return null
      }

      console.log(`Cache hit for contract hash: ${codeHash}, age: ${Math.round(cacheAge / 1000)}s`)
      return result
    } catch (error) {
      console.warn('Failed to get cached analysis result:', error)
      return null
    }
  }

  /**
   * Cache individual pattern matching results
   */
  async cachePatternResult(
    contractCode: string,
    patternId: string,
    result: Omit<CachedPatternResult, 'timestamp'>
  ): Promise<void> {
    try {
      const patternHash = this.generatePatternHash(contractCode, patternId)
      const cacheKey = `pattern:${patternHash}`
      
      const cachedResult: CachedPatternResult = {
        ...result,
        timestamp: Date.now()
      }

      // Use in-memory cache (Redis has been removed)
      this.inMemoryCache.set(cacheKey, cachedResult, this.PATTERN_TTL, 'pattern')
      
      console.log(`Cached pattern result for ${patternId}: ${patternHash}`)
    } catch (error) {
      console.warn(`Failed to cache pattern result for ${patternId}:`, error)
    }
  }

  /**
   * Retrieve cached pattern matching results
   */
  async getCachedPatternResult(
    contractCode: string,
    patternId: string
  ): Promise<CachedPatternResult | null> {
    try {
      const patternHash = this.generatePatternHash(contractCode, patternId)
      const cacheKey = `pattern:${patternHash}`
      
      // Use in-memory cache (Redis has been removed)
      const result: CachedPatternResult | null = this.inMemoryCache.get(cacheKey, 'pattern')
      
      if (!result) {
        return null
      }
      
      // Check if cache is still fresh
      const age = Date.now() - result.timestamp
      if (age > this.PATTERN_TTL * 1000) {
        this.inMemoryCache.delete(cacheKey, 'pattern')
        return null
      }

      console.log(`Retrieved cached pattern result for ${patternId}: ${patternHash}`)
      return result
    } catch (error) {
      console.warn(`Failed to retrieve cached pattern result for ${patternId}:`, error)
      return null
    }
  }

  /**
   * Cache multiple pattern results in batch
   */
  async cachePatternResults(
    contractCode: string,
    results: Array<{
      pattern: VulnerabilityPattern
      result: Omit<CachedPatternResult, 'timestamp'>
    }>
  ): Promise<void> {
    if (results.length === 0) return

    try {
      // Use in-memory cache (Redis has been removed)
      for (const { pattern, result } of results) {
        const patternHash = this.generatePatternHash(contractCode, pattern.id)
        const cacheKey = `pattern:${patternHash}`
        
        const cachedResult: CachedPatternResult = {
          ...result,
          timestamp: Date.now()
        }

        this.inMemoryCache.set(cacheKey, cachedResult, this.PATTERN_TTL, 'pattern')
      }
      
      console.log(`Batch cached ${results.length} pattern results`)
    } catch (error) {
      console.warn('Failed to batch cache pattern results:', error)
    }
  }

  /**
   * Retrieve multiple cached pattern results in batch
   */
  async getCachedPatternResults(
    contractCode: string,
    patterns: VulnerabilityPattern[]
  ): Promise<Map<string, CachedPatternResult>> {
    const results = new Map<string, CachedPatternResult>()
    
    if (patterns.length === 0) return results

    try {
      // Use in-memory cache (Redis has been removed)
      for (const pattern of patterns) {
        const patternHash = this.generatePatternHash(contractCode, pattern.id)
        const cacheKey = `pattern:${patternHash}`
        
        const result = this.inMemoryCache.get(cacheKey, 'pattern')
        if (result) {
          const age = Date.now() - result.timestamp
          if (age <= this.PATTERN_TTL * 1000) {
            results.set(pattern.id, result)
          }
        }
      }

      console.log(`Retrieved ${results.size}/${patterns.length} cached pattern results`)
    } catch (error) {
      console.warn('Failed to retrieve batch pattern cache:', error)
    }

    return results
  }

  /**
   * Invalidate cache for a specific contract
   */
  async invalidateContractCache(contractCode: string): Promise<void> {
    try {
      const codeHash = this.generateCodeHash(contractCode)
      
      // Delete analysis cache
      const analysisKey = `analysis:${codeHash}`
      const hashKey = `hash:${codeHash}`
      
      // Use in-memory cache (Redis has been removed)
      this.inMemoryCache.delete(analysisKey, 'analysis')
      this.inMemoryCache.delete(hashKey, 'hash')
      
      console.log(`Invalidated cache for contract hash: ${codeHash}`)
    } catch (error) {
      console.warn('Failed to invalidate contract cache:', error)
    }
  }

  /**
   * Get cache statistics
   */
  async getCacheStats(): Promise<{
    analysisCount: number
    patternCount: number
    totalKeys: number
  }> {
    try {
      // Use in-memory cache stats (Redis has been removed)
      return this.inMemoryCache.getStats()
    } catch (error) {
      console.warn('Failed to get cache stats:', error)
      return { analysisCount: 0, patternCount: 0, totalKeys: 0 }
    }
  }

  /**
   * Clear all vulnerability cache
   */
  async clearCache(): Promise<void> {
    try {
      // Clear in-memory cache (Redis has been removed)
      this.inMemoryCache.clear()
      console.log('Cleared in-memory cache')
    } catch (error) {
      console.warn('Failed to clear cache:', error)
    }
  }
}

export const vulnerabilityCache = new VulnerabilityCache()