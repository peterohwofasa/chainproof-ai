export interface VulnerabilityPattern {
  id: string
  title: string
  description: string
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO'
  category: string
  cweId?: string
  swcId?: string
  patterns: string[]
  examples: string[]
  recommendations: string[]
  references: string[]
}

export const VULNERABILITY_PATTERNS: VulnerabilityPattern[] = [
  {
    id: 'reentrancy',
    title: 'Reentrancy Attack',
    description: 'A contract calls an external contract before updating its own state, allowing the external contract to call back into the original function and re-execute logic before the original state changes are complete.',
    severity: 'CRITICAL',
    category: 'Reentrancy',
    cweId: 'CWE-841',
    swcId: 'SWC-107',
    patterns: [
      '\\w+\\.call\\s*\\([^)]*\\)\\s*;?\\s*\\n\\s*\\w+\\[\\w+\\]\\s*=',
      '\\.transfer\\s*\\([^)]*\\)\\s*;?\\s*\\n\\s*\\w+\\[\\w+\\]\\s*=',
      '\\.send\\s*\\([^)]*\\)\\s*;?\\s*\\n\\s*\\w+\\[\\w+\\]\\s*='
    ],
    examples: [
      'function withdraw(uint amount) public {\n    require(balances[msg.sender] >= amount);\n    (bool success,) = msg.sender.call{value: amount}("");\n    require(success, "Transfer failed");\n    balances[msg.sender] -= amount; // State change after external call\n}'
    ],
    recommendations: [
      'Implement the checks-effects-interactions pattern',
      'Use OpenZeppelin\'s ReentrancyGuard modifier',
      'Update state variables before making external calls',
      'Consider using pull over push payment patterns'
    ],
    references: [
      'https://swcregistry.io/docs/SWC-107',
      'https://cwe.mitre.org/data/definitions/841.html',
      'https://docs.openzeppelin.com/contracts/4.x/security-recommendations#reentrancy'
    ]
  },
  {
    id: 'integer_overflow',
    title: 'Integer Overflow/Underflow',
    description: 'Arithmetic operations can exceed the maximum or minimum values that can be stored in the data type, leading to unexpected behavior.',
    severity: 'HIGH',
    category: 'Integer Overflow',
    cweId: 'CWE-190',
    swcId: 'SWC-101',
    patterns: [
      '\\w+\\s*[+\\-*/]\\s*=\\s*\\w+',
      '\\w+\\s*=\\s*\\w+\\s*[+\\-*/]\\s*\\w+',
      'pragma solidity\\s+\\^0\\.[4567]'
    ],
    examples: [
      'function addToBalance(uint amount) public {\n    balances[msg.sender] += amount; // Potential overflow\n}',
      'function subtractFromBalance(uint amount) public {\n    balances[msg.sender] -= amount; // Potential underflow\n}'
    ],
    recommendations: [
      'Use Solidity version 0.8.0 or later which has built-in overflow protection',
      'Use SafeMath library for older Solidity versions',
      'Add proper bounds checking before arithmetic operations',
      'Consider using checked arithmetic patterns'
    ],
    references: [
      'https://swcregistry.io/docs/SWC-101',
      'https://cwe.mitre.org/data/definitions/190.html',
      'https://docs.soliditylang.org/en/v0.8.0/security-considerations.html#integer-overflow-and-underflow'
    ]
  },
  {
    id: 'access_control',
    title: 'Missing Access Control',
    description: 'Functions that should be restricted to specific users (like owners) are publicly accessible without proper access controls.',
    severity: 'HIGH',
    category: 'Access Control',
    cweId: 'CWE-284',
    swcId: 'SWC-100',
    patterns: [
      'function\\s+\\w+.*?(public|external).*?(?!.*require\\s*\\(\\s*msg\\.sender)',
      'function\\s+\\w+.*?(public|external).*?(?!.*onlyOwner)',
      'function\\s+set\\w+.*?(public|external)'
    ],
    examples: [
      'function setOwner(address newOwner) public { // No access control\n    owner = newOwner;\n}',
      'function withdraw() public { // Anyone can withdraw\n    (bool success,) = owner.call{value: address(this).balance}("");\n    require(success);\n}'
    ],
    recommendations: [
      'Implement proper access control modifiers (onlyOwner, etc.)',
      'Use require statements to check msg.sender or role-based permissions',
      'Consider using OpenZeppelin\'s AccessControl for complex permission systems',
      'Follow the principle of least privilege'
    ],
    references: [
      'https://swcregistry.io/docs/SWC-100',
      'https://cwe.mitre.org/data/definitions/284.html',
      'https://docs.openzeppelin.com/contracts/4.x/access-control'
    ]
  },
  {
    id: 'unchecked_call',
    title: 'Unchecked External Call Return Value',
    description: 'External calls (call, delegatecall, send, transfer) return values are not checked, which can lead to silent failures.',
    severity: 'MEDIUM',
    category: 'External Calls',
    cweId: 'CWE-252',
    swcId: 'SWC-104',
    patterns: [
      '\\w+\\.(call|delegatecall|staticcall|transfer|send)\\s*\\([^)]*\\)\\s*(?!.*\\.|.*\\()',
      '\\.call\\s*\\([^)]*\\)\\s*;?\\s*\\n(?!.*require|.*if)'
    ],
    examples: [
      'function deposit() public payable {\n    (bool success,) = recipient.call{value: msg.value}("");\n    // Missing success check\n}',
      'token.transfer(to, amount); // Return value not checked'
    ],
    recommendations: [
      'Always check the return value of external calls',
      'Use require() or if statements to handle failures',
      'Consider using .call() with proper error handling instead of transfer()',
      'Implement fallback mechanisms for failed calls'
    ],
    references: [
      'https://swcregistry.io/docs/SWC-104',
      'https://cwe.mitre.org/data/definitions/252.html',
      'https://docs.soliditylang.org/en/latest/security-considerations.html#low-level-call-methods'
    ]
  },
  {
    id: 'selfdestruct',
    title: 'Selfdestruct Usage',
    description: 'Selfdestruct can be used to destroy contracts and potentially drain funds if used maliciously.',
    severity: 'CRITICAL',
    category: 'Denial of Service',
    cweId: 'CWE-755',
    swcId: 'SWC-106',
    patterns: [
      'selfdestruct\\s*\\(\\s*\\w+\\s*\\)',
      'suicide\\s*\\(\\s*\\w+\\s*\\)'
    ],
    examples: [
      'function destroy() public {\n    selfdestruct(msg.sender); // Anyone can destroy contract\n}',
      'function emergencyDestroy() public {\n    if (emergency) {\n        selfdestruct(owner);\n    }\n}'
    ],
    recommendations: [
      'Avoid using selfdestruct when possible',
      'Implement strict access controls if selfdestruct is necessary',
      'Consider using upgradeable patterns instead of destruction',
      'Use pausable contracts for emergency stops'
    ],
    references: [
      'https://swcregistry.io/docs/SWC-106',
      'https://cwe.mitre.org/data/definitions/755.html',
      'https://eips.ethereum.org/EIPS/eip-6049'
    ]
  },
  {
    id: 'delegatecall',
    title: 'Dangerous Delegatecall',
    description: 'Delegatecall to user-supplied or mutable addresses can lead to code injection and state manipulation.',
    severity: 'CRITICAL',
    category: 'Delegatecall',
    cweId: 'CWE-94',
    swcId: 'SWC-112',
    patterns: [
      'delegatecall\\s*\\(\\s*[^)]*\\w+[^)]*\\s*\\)',
      '\\w+\\.delegatecall\\s*\\(\\s*[^)]*\\w+[^)]*\\s*\\)'
    ],
    examples: [
      'function execute(address target, bytes memory data) public {\n    target.delegatecall(data); // User-supplied target\n}',
      'function upgrade(address newImplementation) public {\n        newImplementation.delegatecall(abi.encodeWithSignature("initialize()"));\n    }'
    ],
    recommendations: [
      'Avoid delegatecall to user-supplied addresses',
      'Use verified implementation contracts only',
      'Implement proper access controls for delegatecall operations',
      'Consider using proxy patterns like OpenZeppelin\'s upgradeable contracts'
    ],
    references: [
      'https://swcregistry.io/docs/SWC-112',
      'https://cwe.mitre.org/data/definitions/94.html',
      'https://docs.openzeppelin.com/contracts/4.x/upgrades-proxies'
    ]
  },
  {
    id: 'timestamp_dependence',
    title: 'Timestamp Dependence',
    description: 'Using block.timestamp for critical logic can be manipulated by miners within a small range.',
    severity: 'LOW',
    category: 'Bad Randomness',
    cweId: 'CWE-642',
    swcId: 'SWC-116',
    patterns: [
      'block\\.timestamp',
      '\\bnow\\b'
    ],
    examples: [
      'function lottery() public {\n    if (block.timestamp % 2 == 0) {\n        winner = msg.sender;\n    }\n}',
      'uint256 random = uint256(block.timestamp) % 100;'
    ],
    recommendations: [
      'Avoid using block.timestamp for critical operations',
      'Use block.number for more predictable timing',
      'Consider using Chainlink VRF for true randomness',
      'Implement multiple sources of entropy if randomness is needed'
    ],
    references: [
      'https://swcregistry.io/docs/SWC-116',
      'https://cwe.mitre.org/data/definitions/642.html',
      'https://docs.chain.link/docs/vrf/'
    ]
  },
  {
    id: 'gas_limit_dos',
    title: 'Gas Limit DoS',
    description: 'Operations that consume unbounded gas can cause transactions to fail or be manipulated.',
    severity: 'MEDIUM',
    category: 'Gas Optimization',
    cweId: 'CWE-400',
    swcId: 'SWC-128',
    patterns: [
      'for\\s*\\([^)]*\\)\\s*{[^}]*\\w+\\[\\w+\\]',
      'while\\s*\\([^)]*\\)\\s*{[^}]*\\w+\\[\\w+\\]'
    ],
    examples: [
      'function distribute() public {\n    for (uint i = 0; i < users.length; i++) {\n        users[i].transfer(1 ether); // Gas limit issues\n    }\n}',
      'function processArray(address[] memory recipients) public {\n    for (uint i = 0; i < recipients.length; i++) {\n        balances[recipients[i]] += 1;\n    }\n}'
    ],
    recommendations: [
      'Limit the number of iterations in loops',
      'Use pull patterns instead of push for distributions',
      'Implement batch processing with reasonable limits',
      'Consider using events for off-chain processing'
    ],
    references: [
      'https://swcregistry.io/docs/SWC-128',
      'https://cwe.mitre.org/data/definitions/400.html',
      'https://docs.soliditylang.org/en/latest/security-considerations.html#gas-limit-and-gas-griefing'
    ]
  },
  {
    id: 'front_running',
    title: 'Front-Running Vulnerability',
    description: 'Transaction ordering dependencies can be exploited by front-running transactions.',
    severity: 'MEDIUM',
    category: 'Front-Running',
    cweId: 'CWE-664',
    swcId: 'SWC-120',
    patterns: [
      'require\\s*\\(\\s*block\\.number\\s*[><=]',
      'if\\s*\\(\\s*block\\.number\\s*[><=]'
    ],
    examples: [
      'function claimReward() public {\n    require(block.number > lastClaimBlock[msg.sender]);\n    // Vulnerable to front-running\n}',
      'function finalizeAuction() public {\n    if (block.number >= auctionEnd) {\n        winner = highestBidder;\n    }\n}'
    ],
    recommendations: [
      'Use commit-reveal schemes for sensitive operations',
      'Implement time-based delays with randomness',
      'Consider using submarine sends or batch auctions',
      'Design systems to be resistant to transaction ordering'
    ],
    references: [
      'https://swcregistry.io/docs/SWC-120',
      'https://cwe.mitre.org/data/definitions/664.html',
      'https://www.paradigm.xyz/2020/08/commit-reveal-schemes'
    ]
  },
  {
    id: 'logic_error',
    title: 'Business Logic Error',
    description: 'Flaws in the contract\'s business logic that can lead to unexpected behavior or exploitation.',
    severity: 'HIGH',
    category: 'Logic Error',
    cweId: 'CWE-840',
    swcId: 'SWC-135',
    patterns: [
      '/\\s*\\w+',
      '\\w+\\s*/\\s*\\w+',
      'require\\s*\\(\\s*\\w+\\s*[><=]\\s*\\w+\\s*\\)'
    ],
    examples: [
      'function withdraw(uint amount) public {\n    require(amount <= balance); // Should be <= balances[msg.sender]\n    (bool success,) = msg.sender.call{value: amount}("");\n    require(success);\n}',
      'function calculateReward() public view returns (uint) {\n    return balance / 0; // Division by zero\n}'
    ],
    recommendations: [
      'Thoroughly test business logic with edge cases',
      'Implement comprehensive input validation',
      'Use formal verification for critical logic',
      'Conduct external security audits'
    ],
    references: [
      'https://swcregistry.io/docs/SWC-135',
      'https://cwe.mitre.org/data/definitions/840.html',
      'https://docs.soliditylang.org/en/latest/security-considerations.html#general-philosophy'
    ]
  },
  {
    id: 'event_logging',
    title: 'Missing Event Logging',
    description: 'Important state changes are not logged with events, reducing transparency and making off-chain monitoring difficult.',
    severity: 'LOW',
    category: 'Event Logging',
    cweId: 'CWE-778',
    swcId: 'SWC-132',
    patterns: [
      '\\w+\\[\\w+\\]\\s*=\\s*\\w+(?!.*emit)',
      'require\\s*\\([^)]*\\)(?!.*emit)'
    ],
    examples: [
      'function setPrice(uint newPrice) public {\n    price = newPrice; // Missing event\n}',
      'function transfer(address to, uint amount) public {\n    balances[msg.sender] -= amount;\n    balances[to] += amount; // No Transfer event\n}'
    ],
    recommendations: [
      'Emit events for all important state changes',
      'Follow ERC event standards (ERC20, ERC721, etc.)',
      'Include all relevant parameters in events',
      'Use events for off-chain monitoring and indexing'
    ],
    references: [
      'https://swcregistry.io/docs/SWC-132',
      'https://cwe.mitre.org/data/definitions/778.html',
      'https://docs.soliditylang.org/en/latest/contracts.html#events'
    ]
  }
]

export class VulnerabilityDatabase {
  private patterns: Map<string, VulnerabilityPattern> = new Map()

  constructor() {
    VULNERABILITY_PATTERNS.forEach(pattern => {
      this.patterns.set(pattern.id, pattern)
    })
  }

  getPattern(id: string): VulnerabilityPattern | undefined {
    return this.patterns.get(id)
  }

  getAllPatterns(): VulnerabilityPattern[] {
    return Array.from(this.patterns.values())
  }

  getPatternsByCategory(category: string): VulnerabilityPattern[] {
    return Array.from(this.patterns.values()).filter(p => p.category === category)
  }

  getPatternsBySeverity(severity: string): VulnerabilityPattern[] {
    return Array.from(this.patterns.values()).filter(p => p.severity === severity)
  }

  searchPatterns(query: string): VulnerabilityPattern[] {
    const lowerQuery = query.toLowerCase()
    return Array.from(this.patterns.values()).filter(p => 
      p.title.toLowerCase().includes(lowerQuery) ||
      p.description.toLowerCase().includes(lowerQuery) ||
      p.category.toLowerCase().includes(lowerQuery)
    )
  }

  getVulnerabilityContext(vulnerabilityIds: string[]): string {
    const contexts: string[] = []
    
    vulnerabilityIds.forEach(id => {
      const pattern = this.getPattern(id)
      if (pattern) {
        contexts.push(`**${pattern.title} (${pattern.severity})**`)
        contexts.push(`Description: ${pattern.description}`)
        contexts.push(`Category: ${pattern.category}`)
        if (pattern.cweId) contexts.push(`CWE ID: ${pattern.cweId}`)
        if (pattern.swcId) contexts.push(`SWC ID: ${pattern.swcId}`)
        contexts.push(`Recommendations: ${pattern.recommendations.join(', ')}`)
        contexts.push('')
      }
    })
    
    return contexts.join('\n')
  }

  enhanceVulnerabilityDetection(sourceCode: string): Array<{
    pattern: VulnerabilityPattern
    matches: Array<{ line: number; snippet: string; confidence: number }>
  }> {
    const results: Array<{
      pattern: VulnerabilityPattern
      matches: Array<{ line: number; snippet: string; confidence: number }>
    }> = []

    const lines = sourceCode.split('\n')
    const semanticContext = this.analyzeSemanticContext(sourceCode)

    this.patterns.forEach(pattern => {
      const matches: Array<{ line: number; snippet: string; confidence: number }> = []

      pattern.patterns.forEach(regexPattern => {
        try {
          const regex = new RegExp(regexPattern, 'gi')
          const sourceCodeStr = sourceCode

          let match
          while ((match = regex.exec(sourceCodeStr)) !== null) {
            const lineNumber = sourceCodeStr.substring(0, match.index).split('\n').length
            const snippet = lines[Math.max(0, lineNumber - 1)]

            // Enhanced confidence calculation with semantic context
            const confidence = this.calculateEnhancedConfidence(
              match[0], 
              pattern, 
              snippet, 
              lineNumber, 
              semanticContext
            )

            // Only include matches with reasonable confidence
            if (confidence > 0.3) {
              matches.push({
                line: lineNumber,
                snippet,
                confidence
              })
            }
          }
        } catch (error) {
          console.warn(`Invalid regex pattern for ${pattern.id}:`, regexPattern)
        }
      })

      if (matches.length > 0) {
        results.push({ pattern, matches })
      }
    })

    // Add cross-pattern analysis for complex vulnerabilities
    const crossPatternResults = this.performCrossPatternAnalysis(sourceCode, lines)
    results.push(...crossPatternResults)

    return results
  }

  private analyzeSemanticContext(sourceCode: string): {
    hasAccessControl: boolean
    hasReentrancyGuard: boolean
    solidityVersion: string | null
    hasEvents: boolean
    hasModifiers: boolean
    externalCalls: number
    stateChanges: number
    functions: Array<{ name: string; visibility: string; line: number }>
  } {
    const context = {
      hasAccessControl: false,
      hasReentrancyGuard: false,
      solidityVersion: null as string | null,
      hasEvents: false,
      hasModifiers: false,
      externalCalls: 0,
      stateChanges: 0,
      functions: [] as Array<{ name: string; visibility: string; line: number }>
    }

    const lines = sourceCode.split('\n')

    // Analyze Solidity version
    const versionMatch = sourceCode.match(/pragma\s+solidity\s+([^;]+);/)
    if (versionMatch) {
      context.solidityVersion = versionMatch[1].trim()
    }

    // Check for access control patterns
    context.hasAccessControl = /onlyOwner|require\s*\(\s*msg\.sender\s*==|modifier\s+only/i.test(sourceCode)
    
    // Check for reentrancy guard
    context.hasReentrancyGuard = /ReentrancyGuard|nonReentrant|_reentrancyGuard/i.test(sourceCode)
    
    // Check for events
    context.hasEvents = /event\s+\w+|emit\s+\w+/i.test(sourceCode)
    
    // Check for modifiers
    context.hasModifiers = /modifier\s+\w+/i.test(sourceCode)

    // Count external calls
    const externalCallMatches = sourceCode.match(/\.(call|delegatecall|transfer|send)\s*\(/g)
    context.externalCalls = externalCallMatches ? externalCallMatches.length : 0

    // Count state changes
    const stateChangeMatches = sourceCode.match(/\w+\[\w+\]\s*[=+\-*\/]/g)
    context.stateChanges = stateChangeMatches ? stateChangeMatches.length : 0

    // Extract function information
    lines.forEach((line, index) => {
      const functionMatch = line.match(/function\s+(\w+)\s*\([^)]*\)\s*(public|external|internal|private)?/)
      if (functionMatch) {
        context.functions.push({
          name: functionMatch[1],
          visibility: functionMatch[2] || 'internal',
          line: index + 1
        })
      }
    })

    return context
  }

  private performCrossPatternAnalysis(sourceCode: string, lines: string[]): Array<{
    pattern: VulnerabilityPattern
    matches: Array<{ line: number; snippet: string; confidence: number }>
  }> {
    const results: Array<{
      pattern: VulnerabilityPattern
      matches: Array<{ line: number; snippet: string; confidence: number }>
    }> = []

    // Check for reentrancy patterns (external call followed by state change)
    const reentrancyPattern = this.detectReentrancyPattern(sourceCode, lines)
    if (reentrancyPattern) {
      results.push(reentrancyPattern)
    }

    // Check for access control bypass patterns
    const accessControlPattern = this.detectAccessControlBypass(sourceCode, lines)
    if (accessControlPattern) {
      results.push(accessControlPattern)
    }

    // Check for gas optimization issues
    const gasOptimizationPattern = this.detectGasOptimizationIssues(sourceCode, lines)
    if (gasOptimizationPattern) {
      results.push(gasOptimizationPattern)
    }

    return results
  }

  private detectReentrancyPattern(sourceCode: string, lines: string[]): {
    pattern: VulnerabilityPattern
    matches: Array<{ line: number; snippet: string; confidence: number }>
  } | null {
    const reentrancyPattern = this.getPattern('reentrancy')
    if (!reentrancyPattern) return null

    const matches: Array<{ line: number; snippet: string; confidence: number }> = []
    
    // Look for external calls followed by state changes within the same function
    const functionBlocks = this.extractFunctionBlocks(sourceCode)
    
    functionBlocks.forEach(block => {
      const externalCallMatch = block.content.match(/\.(call|transfer|send)\s*\([^)]*\)/)
      const stateChangeMatch = block.content.match(/\w+\[\w+\]\s*[=+\-]/)
      
      if (externalCallMatch && stateChangeMatch) {
        const externalCallIndex = block.content.indexOf(externalCallMatch[0])
        const stateChangeIndex = block.content.indexOf(stateChangeMatch[0])
        
        // If state change comes after external call, it's a potential reentrancy
        if (stateChangeIndex > externalCallIndex) {
          matches.push({
            line: block.startLine,
            snippet: lines[block.startLine - 1] || '',
            confidence: 0.8
          })
        }
      }
    })

    return matches.length > 0 ? { pattern: reentrancyPattern, matches } : null
  }

  private detectAccessControlBypass(sourceCode: string, lines: string[]): {
    pattern: VulnerabilityPattern
    matches: Array<{ line: number; snippet: string; confidence: number }>
  } | null {
    const accessControlPattern = this.getPattern('access_control')
    if (!accessControlPattern) return null

    const matches: Array<{ line: number; snippet: string; confidence: number }> = []
    
    // Look for public/external functions that modify state without access control
    lines.forEach((line, index) => {
      const functionMatch = line.match(/function\s+(\w+)\s*\([^)]*\)\s*(public|external)/)
      if (functionMatch) {
        const functionName = functionMatch[1]
        
        // Check if it's a sensitive function (set, withdraw, transfer, etc.)
        const isSensitive = /^(set|withdraw|transfer|mint|burn|destroy|upgrade|admin)/i.test(functionName)
        
        if (isSensitive) {
          // Check if there's access control in the function
          const functionContent = this.getFunctionContent(sourceCode, index)
          const hasAccessControl = /require\s*\(\s*msg\.sender|onlyOwner|onlyAdmin/i.test(functionContent)
          
          if (!hasAccessControl) {
            matches.push({
              line: index + 1,
              snippet: line,
              confidence: 0.7
            })
          }
        }
      }
    })

    return matches.length > 0 ? { pattern: accessControlPattern, matches } : null
  }

  private detectGasOptimizationIssues(sourceCode: string, lines: string[]): {
    pattern: VulnerabilityPattern
    matches: Array<{ line: number; snippet: string; confidence: number }>
  } | null {
    const gasPattern = this.getPattern('gas_limit_dos')
    if (!gasPattern) return null

    const matches: Array<{ line: number; snippet: string; confidence: number }> = []
    
    // Look for loops with external calls or unbounded operations
    lines.forEach((line, index) => {
      const loopMatch = line.match(/for\s*\([^)]*\)|while\s*\([^)]*\)/)
      if (loopMatch) {
        const loopContent = this.getLoopContent(sourceCode, index)
        
        // Check for external calls in loops
        const hasExternalCall = /\.(call|transfer|send)\s*\(/.test(loopContent)
        
        // Check for array access without bounds
        const hasUnboundedAccess = /\w+\[\w+\]/.test(loopContent) && !/\.length/.test(line)
        
        if (hasExternalCall || hasUnboundedAccess) {
          matches.push({
            line: index + 1,
            snippet: line,
            confidence: hasExternalCall ? 0.9 : 0.6
          })
        }
      }
    })

    return matches.length > 0 ? { pattern: gasPattern, matches } : null
  }

  private extractFunctionBlocks(sourceCode: string): Array<{ startLine: number; content: string }> {
    const blocks: Array<{ startLine: number; content: string }> = []
    const lines = sourceCode.split('\n')
    
    let currentBlock: { startLine: number; content: string } | null = null
    let braceCount = 0
    
    lines.forEach((line, index) => {
      if (line.match(/function\s+\w+/)) {
        currentBlock = { startLine: index + 1, content: line + '\n' }
        braceCount = (line.match(/\{/g) || []).length - (line.match(/\}/g) || []).length
      } else if (currentBlock) {
        currentBlock.content += line + '\n'
        braceCount += (line.match(/\{/g) || []).length - (line.match(/\}/g) || []).length
        
        if (braceCount === 0) {
          blocks.push(currentBlock)
          currentBlock = null
        }
      }
    })
    
    return blocks
  }

  private getFunctionContent(sourceCode: string, startLineIndex: number): string {
    const lines = sourceCode.split('\n')
    let content = ''
    let braceCount = 0
    
    for (let i = startLineIndex; i < lines.length; i++) {
      const line = lines[i]
      content += line + '\n'
      braceCount += (line.match(/\{/g) || []).length - (line.match(/\}/g) || []).length
      
      if (braceCount === 0 && line.includes('{')) {
        break
      }
    }
    
    return content
  }

  private getLoopContent(sourceCode: string, startLineIndex: number): string {
    const lines = sourceCode.split('\n')
    let content = ''
    let braceCount = 0
    
    for (let i = startLineIndex; i < lines.length; i++) {
      const line = lines[i]
      content += line + '\n'
      braceCount += (line.match(/\{/g) || []).length - (line.match(/\}/g) || []).length
      
      if (braceCount === 0 && line.includes('{')) {
        break
      }
    }
    
    return content
  }

  private calculateEnhancedConfidence(
    match: string, 
    pattern: VulnerabilityPattern, 
    snippet: string, 
    lineNumber: number, 
    context: any
  ): number {
    let confidence = this.calculateConfidence(match, pattern)

    // Adjust confidence based on semantic context
    switch (pattern.id) {
      case 'reentrancy':
        if (!context.hasReentrancyGuard) confidence += 0.2
        if (context.externalCalls > 2) confidence += 0.1
        break
        
      case 'access_control':
        if (!context.hasAccessControl) confidence += 0.3
        if (snippet.includes('public') || snippet.includes('external')) confidence += 0.1
        break
        
      case 'integer_overflow':
        if (context.solidityVersion && context.solidityVersion.includes('0.7')) confidence += 0.2
        if (context.solidityVersion && context.solidityVersion.includes('0.6')) confidence += 0.3
        break
        
      case 'event_logging':
        if (!context.hasEvents) confidence += 0.2
        if (context.stateChanges > 3) confidence += 0.1
        break
        
      case 'gas_limit_dos':
        if (snippet.includes('for') && context.externalCalls > 0) confidence += 0.3
        break
    }

    // Reduce confidence for false positives
    if (snippet.includes('//') && snippet.includes('TODO')) confidence -= 0.2
    if (snippet.includes('require(') && pattern.id === 'access_control') confidence -= 0.1

    return Math.max(0.1, Math.min(confidence, 1.0))
  }

  private calculateConfidence(match: string, pattern: VulnerabilityPattern): number {
    let confidence = 0.5 // Base confidence

    // Increase confidence based on pattern specificity
    if (pattern.patterns.some(p => p.includes('require'))) confidence += 0.2
    if (pattern.patterns.some(p => p.includes('function'))) confidence += 0.1
    if (pattern.patterns.some(p => p.includes('public|external'))) confidence += 0.1

    // Increase confidence for more specific matches
    if (match.includes('msg.sender')) confidence += 0.1
    if (match.includes('call(')) confidence += 0.1
    if (match.includes('transfer(')) confidence += 0.1

    return Math.min(confidence, 1.0)
  }
}

export const vulnerabilityDatabase = new VulnerabilityDatabase()