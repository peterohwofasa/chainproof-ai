import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import connectDB from '@/lib/mongodb'
import { Vulnerability, Audit, Contract } from '@/models'
import { getAuthenticatedUserId } from '@/lib/wallet-auth-utils'
import { z } from 'zod'

enum Severity {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH',
  CRITICAL = 'CRITICAL'
}

const updateVulnerabilitySchema = z.object({
  title: z.string().min(1).optional(),
  description: z.string().optional(),
  severity: z.nativeEnum(Severity).optional(),
  category: z.string().optional(),
  recommendation: z.string().optional(),
  lineNumber: z.number().int().positive().optional(),
  codeSnippet: z.string().optional(),
})

export async function GET(
  request: NextRequest,
  { params }: { params: { vulnerabilityId: string } }
) {
  try {
    await connectDB()
    
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // UNIVERSAL WALLET ACCESS: Get user ID supporting wallet authentication
    const userId = await getAuthenticatedUserId(request)
    if (!userId) {
      return NextResponse.json({ error: 'Unable to authenticate user' }, { status: 401 })
    }

    const vulnerability = await Vulnerability.findById(params.vulnerabilityId)
      .populate({
        path: 'audit',
        populate: {
          path: 'contract',
          select: 'id name address sourceCode project',
          populate: {
            path: 'project',
            select: 'id name userId',
          },
        },
      })
      .lean()

    if (!vulnerability) {
      return NextResponse.json(
        { error: 'Vulnerability not found' },
        { status: 404 }
      )
    }

    // Check if user has access to this vulnerability through the audit - support wallet authentication
    if ((vulnerability as any).audit.userId !== userId) {
      return NextResponse.json(
        { error: 'Access denied' },
        { status: 403 }
      )
    }

    // Format response to match Prisma structure
    const response = {
      ...vulnerability,
      id: (vulnerability as any)._id.toString(),
      audit: {
        ...(vulnerability as any).audit,
        id: (vulnerability as any).audit._id.toString(),
        contract: (vulnerability as any).audit.contract ? {
          ...(vulnerability as any).audit.contract,
          id: (vulnerability as any).audit.contract._id.toString(),
          project: (vulnerability as any).audit.contract.project ? {
            ...(vulnerability as any).audit.contract.project,
            id: (vulnerability as any).audit.contract.project._id.toString(),
          } : null,
        } : null,
      },
    }

    // Remove MongoDB _id fields
    delete (response as any)._id
    delete (response as any).audit._id
    if ((response as any).audit.contract) {
      delete (response as any).audit.contract._id
      if ((response as any).audit.contract.project) {
        delete (response as any).audit.contract.project._id
      }
    }

    return NextResponse.json(response)
  } catch (error) {
    console.error('Error fetching vulnerability:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: { vulnerabilityId: string } }
) {
  try {
    await connectDB()
    
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // UNIVERSAL WALLET ACCESS: Get user ID supporting wallet authentication
    const userId = await getAuthenticatedUserId(request)
    if (!userId) {
      return NextResponse.json({ error: 'Unable to authenticate user' }, { status: 401 })
    }

    const body = await request.json()
    const validatedData = updateVulnerabilitySchema.parse(body)

    // Check if vulnerability exists and user has access
    const existingVulnerability = await Vulnerability.findById(params.vulnerabilityId)
      .populate({
        path: 'audit',
        select: 'userId',
      })
      .lean()

    if (!existingVulnerability) {
      return NextResponse.json(
        { error: 'Vulnerability not found' },
        { status: 404 }
      )
    }

    if ((existingVulnerability as any).audit.userId !== userId) {
      return NextResponse.json(
        { error: 'Access denied' },
        { status: 403 }
      )
    }

    const vulnerability = await Vulnerability.findByIdAndUpdate(
      params.vulnerabilityId,
      validatedData,
      { new: true }
    )
      .populate({
        path: 'audit',
        select: 'id status contract',
        populate: {
          path: 'contract',
          select: 'id name address',
        },
      })
      .lean()

    // Format response to match Prisma structure
    const response = {
      ...vulnerability,
      id: (vulnerability as any)._id.toString(),
      audit: {
        ...(vulnerability as any).audit,
        id: (vulnerability as any).audit._id.toString(),
        contract: (vulnerability as any).audit.contract ? {
          ...(vulnerability as any).audit.contract,
          id: (vulnerability as any).audit.contract._id.toString(),
        } : null,
      },
    }

    // Remove MongoDB _id fields
    delete response._id
    delete response.audit._id
    if (response.audit.contract) {
      delete response.audit.contract._id
    }

    return NextResponse.json(response)
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation error', details: error.errors },
        { status: 400 }
      )
    }

    console.error('Error updating vulnerability:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { vulnerabilityId: string } }
) {
  try {
    await connectDB()
    
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // UNIVERSAL WALLET ACCESS: Get user ID supporting wallet authentication
    const userId = await getAuthenticatedUserId(request)
    if (!userId) {
      return NextResponse.json({ error: 'Unable to authenticate user' }, { status: 401 })
    }

    // Check if vulnerability exists and user has access
    const existingVulnerability = await Vulnerability.findById(params.vulnerabilityId)
      .populate({
        path: 'audit',
        select: 'userId',
      })
      .lean()

    if (!existingVulnerability) {
      return NextResponse.json(
        { error: 'Vulnerability not found' },
        { status: 404 }
      )
    }

    if ((existingVulnerability as any).audit.userId !== userId) {
      return NextResponse.json(
        { error: 'Access denied' },
        { status: 403 }
      )
    }

    await Vulnerability.findByIdAndDelete(params.vulnerabilityId)

    return NextResponse.json({ message: 'Vulnerability deleted successfully' })
  } catch (error) {
    console.error('Error deleting vulnerability:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}